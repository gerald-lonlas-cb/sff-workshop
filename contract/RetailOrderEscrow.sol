// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "hardhat/console.sol";

contract RetailOrderEscrow is
    ERC1155,
    EIP712,
    Ownable,
    Pausable,
    ERC1155Burnable,
    ERC1155Supply
{
    using ECDSA for bytes32;

    constructor() ERC1155("") EIP712("RetailOrderEscrow", "0.0.1") {}

    // sample metadata base URI
    string baseURI =
        "https://raw.githubusercontent.com/StraitsX/NFT-Metadata/main/heroNFT2023SEP/";

    function setURI(string memory baseUri) public onlyOwner {
        baseURI = baseUri;
    }

    function uri(
        uint256 token_id
    ) public view override returns (string memory) {
        return
            string(
                abi.encodePacked(baseURI, Strings.toString(token_id), ".json")
            );
    }

    enum OrderStatus {
        PENDING,
        REDEEMED,
        CANCELLED
    }

    struct Order {
        uint256 order_value; // how much this order cost.
        address merchant_address; // need this to check upon redemption
        OrderStatus status;
    }

    // order_id => Order
    mapping(string => Order) private orders;

    function createOrder(
        string memory order_id,
        uint256 amount,
        address merchant_address
    ) external whenNotPaused {
        // Ensure the order does not already exist
        require(
            orders[order_id].merchant_address == address(0),
            "Order already exists"
        );

        Order memory newOrder = Order({
            order_value: amount,
            merchant_address: merchant_address,
            status: OrderStatus.PENDING
        });

        orders[order_id] = newOrder;
    }

    function cancelOrder(string memory order_id) external whenNotPaused {
        Order storage order = orders[order_id];
        require(order.status == OrderStatus.PENDING, "Cannot cancel order");
        order.status = OrderStatus.CANCELLED;
    }

    struct OrderRedeemRequest {
        address from; // user address
        string order_id;
    }

    // @notice caller must be a merchant
    function redeem(
        OrderRedeemRequest calldata req,
        bytes calldata signature
    ) external whenNotPaused {
        Order storage order = orders[req.order_id];

        require(order.status == OrderStatus.PENDING, "Cannot redeem order");

        // verify the signature by calling verify
        require(verify(req, signature), "Invalid signature");

        order.status = OrderStatus.REDEEMED;
    }

    bytes32 private constant _TYPEHASH =
        keccak256("OrderRedeemRequest(address from,string order_id)");

    // @notice rationale for verify:
    // Without verify, merchant knowing the order details(order_id) could redeem an OrderRedeemRequest without the access to the signature signed by the from address
    // With the verify function, you can be sure that the person who signed the OrderRedeemRequest controls the private key of the from address.
    // The signature is generated by user signing the OrderRedeemRequest and can only obtained by merchant upon user redeeming

    function verify(
        OrderRedeemRequest calldata req,
        bytes calldata signature
    ) public view returns (bool) {
        address signer = _hashTypedDataV4(
            keccak256(
                abi.encode(_TYPEHASH, req.from, keccak256(bytes(req.order_id)))
            )
        ).recover(signature);

        return signer == req.from;
    }

    // Get the status of a single order
    function getOrderStatus(
        string memory order_id
    ) public view returns (OrderStatus) {
        Order memory order = orders[order_id];
        require(order.merchant_address != address(0), "Order does not exist");

        return order.status;
    }

    function overrideOrderStatus(
        string memory order_id,
        OrderStatus status
    ) public onlyOwner {
        // Ensure the order exists
        require(
            orders[order_id].merchant_address != address(0),
            "Order does not exist"
        );

        orders[order_id].status = status;
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }

    function mint(
        address account,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        _mint(account, id, amount, data);
    }

    function mintBatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public {
        _mintBatch(to, ids, amounts, data);
    }

    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal override(ERC1155, ERC1155Supply) whenNotPaused {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    }
}
